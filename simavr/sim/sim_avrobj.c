/*
    sim_avrobj.c

    Loads a .obj file generated by avrasm2.

    Copyright 2023 AlexGuo1998 <AlexGuo1998@163.com>

    This file is part of simavr.

    simavr is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    simavr is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with simavr.  If not, see <http://www.gnu.org/licenses/>.
 */

 /*
     AVR Object File information
     Usually generated by avrasm2, also by avra
     <https://github.com/Ro5bert/avra>. Everything is big-endian.

     File sturcture:
     00:04    End-of-code address (eoca)
     04:08    Signature (00 00 00 1A)
     08       How many bytes (in obj file) for one instruction
     09       Source file count
     0A:1A    Comment (see below)
     1A:eoca  Instructions (see below)
     eoca:EOF 0-terminated source filenames, ends with one more '\0'

     v1:
     * Comment is: "AVR Object File\0"
     * 9 bytes for 1 instruction
     * Layout for each instruction:
         00:03    Address
         03:05    Instruction
         05       File index
         06:08    1-based line number
         08       Is this generated by a macro expansion?
     * Lines > 65534 get capped to 65535, and is not source-debuggable

     v2:
     * comment is: "AVR Obj File v2\0"
     * 10 bytes for 1 instruction
     * Layout for each instruction:
         00:03    Address
         03:05    Instruction
         05       File index
         06:09    1-based line number
         09       Is this generated by a macro expansion?
     * Maximum 16777215 lines (overflow situation untested)
 */


#include <stdio.h>
#include <memory.h>
#include <malloc.h>

#include "sim_avrobj.h"
#include "sim_avr.h"
#include "sim_elf.h"

static int avrobj_read_v2(FILE* f, elf_firmware_t* firmware) {

}

int avrobj_read_firmware(const char* file, elf_firmware_t* firmware)
{
    if (firmware->flash) {
        AVR_LOG(NULL, LOG_ERROR, "%s: flash is already defined\n", __func__);
        return -1;
    }

    if (!file) return -1;
    FILE* f = fopen(file, "rb");
    if (!f) {
        AVR_LOG(NULL, LOG_ERROR, "%s: fopen: %s\n", __func__, file);
        return -1;
    }
    uint8_t header[26];
    size_t n = fread(header, sizeof(header), 1, f);
    if (n != 1) {
        AVR_LOG(NULL, LOG_ERROR, "%s: file truncated: %s\n", __func__, file);
        fclose(f);
        return -1;
    }

    size_t end_location =
        ((size_t)(header[0]) << 24) |
        ((size_t)(header[1]) << 16) |
        ((size_t)(header[2]) << 8) |
        header[3];

    if (memcmp(&header[4], "\0\0\0\x1A", 4) != 0) {
        AVR_LOG(NULL, LOG_ERROR, "%s: invalid signature: %s\n", __func__, file);
        fclose(f);
        return -1;
    }

    uint8_t byte_for_instruction = header[8];
    // We ignore the source filenames (at least for now)

    switch (byte_for_instruction) {
    case 9:
        if (memcmp(&header[10], "AVR Object File\0", 16) != 0) {
            AVR_LOG(NULL, LOG_ERROR, "%s: invalid comment: %s\n", __func__, file);
            fclose(f);
            return -1;
        }
        break;
    case 10:
        if (memcmp(&header[10], "AVR Obj File v2\0", 16) != 0) {
            AVR_LOG(NULL, LOG_ERROR, "%s: invalid comment: %s\n", __func__, file);
            fclose(f);
            return -1;
        }
        break;
    default:
        AVR_LOG(NULL, LOG_ERROR, "%s: invalid byte_for_instruction: %s\n", __func__, file);
        fclose(f);
        return -1;
    }
    if (end_location < sizeof(header)
        || (end_location - sizeof(header)) % byte_for_instruction != 0) {
        AVR_LOG(NULL, LOG_ERROR, "%s: invalid end_location: %s\n", __func__, file);
        fclose(f);
        return -1;
    }

    // Read the instructions 2-pass

    // Pass 1: determine base and size
    unsigned long i = sizeof(header);
    uint32_t word_addr_min = UINT32_MAX, word_addr_max = 0;
    while (i < end_location) {
        uint8_t buffer[16];
        n = fread(buffer, byte_for_instruction, 1, f);
        if (n != 1) {
            AVR_LOG(NULL, LOG_ERROR, "%s: file truncated: %s\n", __func__, file);
            fclose(f);
            return -1;
        }
        i += byte_for_instruction;
        uint32_t address =
            ((uint32_t)(buffer[0]) << 16) |
            ((uint32_t)(buffer[1]) << 8) |
            buffer[2];
        if (address < word_addr_min) word_addr_min = address;
        if (address > word_addr_max) word_addr_max = address;
    }
    if (word_addr_max < word_addr_min) {
        AVR_LOG(NULL, LOG_ERROR, "%s: empty flash: %s\n", __func__, file);
        fclose(f);
        return -1;
    }

    // Pass 2: fill the data
    uint32_t flashbase = word_addr_min * 2;
    uint32_t flashsize = (word_addr_max - word_addr_min + 1) * 2;
    uint8_t* flash = malloc(flashsize);
    if (!flash) {
        AVR_LOG(NULL, LOG_ERROR, "%s: malloc %ul: %s\n", __func__, flashsize, file);
        fclose(f);
        return -1;
    }
    memset(flash, 0, flashsize);

    fseek(f, sizeof(header), SEEK_SET);
    i = sizeof(header);
    while (i < end_location) {
        uint8_t buffer[16];
        n = fread(buffer, byte_for_instruction, 1, f);
        if (n != 1) {
            AVR_LOG(NULL, LOG_ERROR, "%s: file changed: %s\n", __func__, file);
            fclose(f);
            free(flash);
            return -1;
        }
        i += byte_for_instruction;
        uint32_t address =
            ((uint32_t)(buffer[0]) << 16) |
            ((uint32_t)(buffer[1]) << 8) |
            buffer[2];
        if (address < word_addr_min || address > word_addr_max) {
            AVR_LOG(NULL, LOG_ERROR, "%s: file changed: %s\n", __func__, file);
            fclose(f);
            free(flash);
            return -1;
        }
        // bitness swapped
        flash[address * 2 - flashbase] = buffer[4];
        flash[address * 2 - flashbase + 1] = buffer[3];
    }
    fclose(f);

    // do it!
    firmware->flash = flash;
    firmware->flashsize = flashsize;
    firmware->flashbase = flashbase;

    AVR_LOG(NULL, LOG_TRACE, "Load OBJ flash %08x, %d at %08x\n\n",
        flashbase, flashsize, flashbase);

    return 0;
}

